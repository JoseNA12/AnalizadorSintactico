package sintactico;

import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import java.io.InputStream;
// http://www2.cs.tum.edu/projects/cup/docs.php
// https://www.youtube.com/watch?v=AQkd5AwjV1E
// http://themfgeek.blogspot.com/2012/10/sintaxis-cup.html
// https://www.youtube.com/watch?v=bBuWPmDrF5M
// https://youtu.be/tSaPDOT2I_4?t=1120
// https://github.com/jflex-de/jflex/blob/master/jflex/examples/cup-java/src/main/cup/java12.cup
// DÃ­as de trabajo: Octubre: 17, 19, 20, 21

// TODO: QUITAR -> case, repeat y arreglos.

parser code
{:
    // Metodo al que se llama automaticamente ante algun error sintactico
    public void syntax_error(Symbol s)
    {
        String lexema = s.value.toString();
        int fila = s.left + 1;
        int columna = s.right;

        System.err.println("Error sintactico en la linea: " + fila + " y columna: " + columna + ". No se esperaba el componente: " + lexema);
    }

    // Metodo al que se llama en el momento en que ya no es posible una recuperacion de errores
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {
        String lexema = s.value.toString();
        int fila = s.left + 1;
        int columna = s.right;

        System.err.println("Error sintactico inrrecuperable en la linea: " + fila + " y columna: " + columna + ". No se esperaba el componente: " + lexema);
    }

    public void report_error(String message, Object info)
    {
        StringBuffer m = new StringBuffer(message);
        if (info instanceof Symbol)
        {
            if (((Symbol)info).left != -1 && ((Symbol)info).right != -1)
            {
            int line = (((Symbol)info).left)+1;
            int column = (((Symbol)info).right)+1;
            m.append(" (line "+line+", column "+column+")");
            }
        }
        System.err.println(m);
    }
:}

// |-------------------- TERMINALES --------------------| //

// Operadores
terminal OPERADOR,
        OPERADOR_INCREMENTO,
        OPERADOR_DISMINUCION,
        OPERADOR_MAYOR_IGUAL_QUE,
        OPERADOR_MAYOR_QUE,
        OPERADOR_MENOR_IGUAL_QUE,
        OPERADOR_MENOR_QUE,
        OPERADOR_ADICION,
        OPERADOR_SUSTRACCION,
        OPERADOR_MULTIPLICACION,
        OPERADOR_DIVISION,
        OPERADOR_PARENTESIS_ABRIR,
        OPERADOR_PARENTESIS_CERRAR,
        OPERADOR_CORCHETE_ABRIR,
        OPERADOR_CORCHETE_CERRAR,
        OPERADOR_ASIGNACION,
        OPERADOR_DIFERENTE_DE,
        OPERADOR_IGUAL_A,
        OPERADOR_ASIGNACION_ADICION,
        OPERADOR_ASIGNACION_SUSTRACCION,
        OPERADOR_ASIGNACION_MULTIPLICACION,
        OPERADOR_ASIGNACION_DIVISION,
        OPERADOR_DESPLAZAMIENTO_DERECHA,
        OPERADOR_DESPLAZAMIENTO_IZQUIERDA,
        OPERADOR_ASIGNACION_DESPLAZAMIENTO_DERECHA,
        OPERADOR_ASIGNACION_DESPLAZAMIENTO_IZQUIERDA,

        OPERADOR_COMA,
        OPERADOR_PUNTO_Y_COMA,
        OPERADOR_DOS_PUNTOS,

        OR, AND, NOT;

terminal IDENTIFICADOR,
        LITERAL_NUM_FLOTANTE,
        LITERAL_STRING,
        LITERAL_NUM_ENTERO,
        PALABRA_RESERVADA;

terminal PROGRAM, BEGIN, END, CONST, VAR, FUNCTION, PROCEDURE;

terminal IF, THEN, ELSE;

terminal TRUE, FALSE;

terminal INT, LONGINT, SHORTINT, CHAR, STRING, BOOLEAN, REAL;


terminal ERROR_IDENTIFICADOR,
        ERROR_LITERAL,
        ERROR_PALABRA_RESERVADA,
        ERROR_OPERADOR;

// |-------------------- NO TERMINALES --------------------| //

non terminal inicio, programa, encabezado, cuerpo, variables, constantes, tipos, declarar_datos, declarar_funciones,
            declarar_procedimientos, asignar_valores, parametros_entrada, cuerpo_func_proc, retorno_funcion, boolean;

non terminal sentencia_if, condicion_if, sentencia_else, valores, _condicion_if;

non terminal Symbol epsilon;

start with inicio;

// |-------------------- REGLAS SEMANTICAS --------------------| //

inicio ::= programa {: System.out.println("Correcto!"); :};

programa ::= PROGRAM IDENTIFICADOR encabezado BEGIN cuerpo END;

encabezado ::= declarar_datos declarar_funciones declarar_procedimientos;

declarar_datos ::= VAR variables declarar_datos
                | CONST constantes declarar_datos
                | epsilon;

variables ::= IDENTIFICADOR OPERADOR_DOS_PUNTOS tipos
            | IDENTIFICADOR OPERADOR_COMA variables;

constantes ::= IDENTIFICADOR OPERADOR_DOS_PUNTOS tipos
            | IDENTIFICADOR OPERADOR_COMA constantes;

declarar_funciones ::= FUNCTION IDENTIFICADOR OPERADOR_PARENTESIS_ABRIR parametros_entrada OPERADOR_PARENTESIS_CERRAR OPERADOR_DOS_PUNTOS tipos
                    BEGIN
                    cuerpo_func_proc
                    retorno_funcion
                    END
                    declarar_funciones
                    | epsilon;

declarar_procedimientos ::= PROCEDURE IDENTIFICADOR OPERADOR_PARENTESIS_ABRIR parametros_entrada OPERADOR_PARENTESIS_CERRAR
                    BEGIN
                    cuerpo_func_proc
                    END
                    declarar_procedimientos
                    | epsilon;

parametros_entrada ::= tipos IDENTIFICADOR
                    | tipos IDENTIFICADOR OPERADOR_COMA parametros_entrada;

cuerpo_func_proc ::= declarar_datos;

tipos ::= INT | SHORTINT | LONGINT | REAL | STRING | CHAR | BOOLEAN;

asignar_valores ::= IDENTIFICADOR OPERADOR_ASIGNACION valores OPERADOR_PUNTO_Y_COMA;

retorno_funcion ::= IDENTIFICADOR OPERADOR_ASIGNACION valores;

cuerpo ::= sentencia_if | epsilon; // modificar

sentencia_if ::= IF condicion_if THEN // meter lo que puede tener el if
            | IF condicion_if THEN sentencia_else;

condicion_if ::= valores OPERADOR_MAYOR_QUE valores _condicion_if
            | valores OPERADOR_MAYOR_IGUAL_QUE valores _condicion_if
            | valores OPERADOR_MENOR_QUE valores _condicion_if
            | valores OPERADOR_MENOR_IGUAL_QUE valores _condicion_if
            | valores OPERADOR_ASIGNACION valores _condicion_if
            | valores OPERADOR_DIFERENTE_DE valores _condicion_if
            | OPERADOR_PARENTESIS_ABRIR condicion_if OPERADOR_PARENTESIS_CERRAR _condicion_if;

_condicion_if ::= AND condicion_if | OR condicion_if | epsilon;

sentencia_else ::= ELSE END
                | ELSE sentencia_if END;

valores ::= IDENTIFICADOR | LITERAL_NUM_ENTERO | LITERAL_NUM_FLOTANTE | LITERAL_STRING | boolean;
boolean ::= TRUE | FALSE;

epsilon ::= {: RESULT = new Symbol(-1); :};