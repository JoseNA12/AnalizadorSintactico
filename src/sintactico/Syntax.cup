package sintactico;

import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import java.io.InputStream;
// http://www2.cs.tum.edu/projects/cup/docs.php
// https://www.youtube.com/watch?v=AQkd5AwjV1E
// http://themfgeek.blogspot.com/2012/10/sintaxis-cup.html
// https://www.youtube.com/watch?v=bBuWPmDrF5M
// https://youtu.be/tSaPDOT2I_4?t=1120
// https://github.com/jflex-de/jflex/blob/master/jflex/examples/cup-java/src/main/cup/java12.cup
// Días de trabajo: Octubre: 17, 19, 20, 21

// TODO: QUITAR -> case, repeat y arreglos.

parser code
{:
    // Metodo al que se llama automaticamente ante algun error sintactico
    public void syntax_error(Symbol s)
    {
        String lexema = s.value.toString();
        int fila = s.left + 1;
        int columna = s.right;

        System.err.println("Error sintactico en la linea: " + fila + " y columna: " + columna + ". No se esperaba el componente: " + lexema);
    }

    // Metodo al que se llama en el momento en que ya no es posible una recuperacion de errores
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {
        String lexema = s.value.toString();
        int fila = s.left + 1;
        int columna = s.right;

        System.err.println("Error sintactico inrrecuperable en la linea: " + fila + " y columna: " + columna + ". No se esperaba el componente: " + lexema);
    }

    public void report_error(String message, Object info)
    {
        StringBuffer m = new StringBuffer(message);
        if (info instanceof Symbol)
        {
            if (((Symbol)info).left != -1 && ((Symbol)info).right != -1)
            {
            int line = (((Symbol)info).left)+1;
            int column = (((Symbol)info).right)+1;
            m.append(" (line "+line+", column "+column+")");
            }
        }
        System.err.println(m);
    }
:}

// |-------------------- TERMINALES --------------------| //

// Operadores
terminal OPERADOR,
        OPERADOR_INCREMENTO,
        OPERADOR_DISMINUCION,
        OPERADOR_MAYOR_IGUAL_QUE,
        OPERADOR_MAYOR_QUE,
        OPERADOR_MENOR_IGUAL_QUE,
        OPERADOR_MENOR_QUE,
        OPERADOR_ADICION,
        OPERADOR_SUSTRACCION,
        OPERADOR_MULTIPLICACION,
        OPERADOR_DIVISION,
        OPERADOR_PARENTESIS_ABRIR,
        OPERADOR_PARENTESIS_CERRAR,
        OPERADOR_CORCHETE_ABRIR,
        OPERADOR_CORCHETE_CERRAR,
        OPERADOR_ASIGNACION,
        OPERADOR_DIFERENTE_DE,
        OPERADOR_ASIGNACION_ADICION,
        OPERADOR_ASIGNACION_SUSTRACCION,
        OPERADOR_ASIGNACION_MULTIPLICACION,
        OPERADOR_ASIGNACION_DIVISION,
        OPERADOR_DESPLAZAMIENTO_DERECHA,
        OPERADOR_DESPLAZAMIENTO_IZQUIERDA,
        OPERADOR_ASIGNACION_DESPLAZAMIENTO_DERECHA,
        OPERADOR_ASIGNACION_DESPLAZAMIENTO_IZQUIERDA,

        OPERADOR_COMA,
        OPERADOR_PUNTO_Y_COMA,
        OPERADOR_DOS_PUNTOS,

        OR, AND, NOT,

        MOD, DIV;

terminal IDENTIFICADOR,
        LITERAL_NUM_FLOTANTE,
        LITERAL_STRING,
        LITERAL_NUM_ENTERO,
        PALABRA_RESERVADA;

terminal PROGRAM, BEGIN, END, CONST, VAR, FUNCTION, PROCEDURE, READ, WRITE;

terminal IF, THEN, ELSE, WHILE, REPEAT, UNTIL, FOR, TO, DO;

terminal TRUE, FALSE;

terminal INT, LONGINT, SHORTINT, CHAR, STRING, BOOLEAN, REAL;


terminal ERROR_IDENTIFICADOR,
        ERROR_LITERAL,
        ERROR_PALABRA_RESERVADA,
        ERROR_OPERADOR;

// |-------------------- NO TERMINALES --------------------| //

non terminal inicio, programa, encabezado, _encabezado, cuerpo, _cuerpo, variables, constantes, tipos, declarar_datos,
            declarar_funciones, declarar_procedimientos, asignar_valores, _asignar_valores, parametros_entrada,
            retorno_funcion, expr_aritmeticas, expr_aritmeticas_, expr_aritmeticas__, _expr_aritmeticas, __expr_aritmeticas,
            ___expr_aritmeticas, ____expr_aritmeticas, operadores_aritmeticos, _operadores_aritmeticos, __operadores_aritmeticos,
            ___operadores_aritmeticos, estruc_de_control, parametros_llamada_func, _parametros_llamada_func, llamar_func_o_proc,
            _llamar_func_o_proc, expr_read_write, expr_read, _expr_read, expr_write, _expr_write,

            sentencia_if, _sentencia_if, expr_booleanas, sentencia_else, _sentencia_else, tokens, _tokens,
            _expr_booleanas, sentencia_while, sentencia_for, operadores_booleanos, tokens_boolean;

non terminal Symbol epsilon;

start with inicio;

// ------------------------------ Start --------------------------------------------------------------------------------

inicio ::= programa {: System.out.println("Correcto!"); :};

programa ::= PROGRAM IDENTIFICADOR encabezado
            BEGIN
            cuerpo
            END;

// ------------------------------ Encabezado ---------------------------------------------------------------------------
encabezado ::= declarar_datos encabezado | declarar_funciones encabezado | declarar_procedimientos encabezado | epsilon;

declarar_datos ::= VAR variables
                | CONST constantes;

variables ::= IDENTIFICADOR OPERADOR_DOS_PUNTOS tipos OPERADOR_PUNTO_Y_COMA
            | IDENTIFICADOR OPERADOR_COMA variables;

constantes ::= IDENTIFICADOR OPERADOR_ASIGNACION tokens OPERADOR_PUNTO_Y_COMA
            | IDENTIFICADOR OPERADOR_COMA constantes;

declarar_funciones ::= FUNCTION IDENTIFICADOR OPERADOR_PARENTESIS_ABRIR parametros_entrada OPERADOR_PARENTESIS_CERRAR OPERADOR_DOS_PUNTOS tipos
                    BEGIN
                    cuerpo
                    // asignar_valores
                    END;

declarar_procedimientos ::= PROCEDURE IDENTIFICADOR OPERADOR_PARENTESIS_ABRIR parametros_entrada OPERADOR_PARENTESIS_CERRAR
                    BEGIN
                    cuerpo
                    END;

parametros_entrada ::= tipos IDENTIFICADOR
                    | tipos IDENTIFICADOR OPERADOR_COMA parametros_entrada;

retorno_funcion ::= IDENTIFICADOR OPERADOR_ASIGNACION expr_aritmeticas; // seria bueno agregar expr_aritmeticas

// ------------------------------ Cuerpo -------------------------------------------------------------------------------

cuerpo ::= asignar_valores cuerpo
         | declarar_datos cuerpo
         | expr_read_write cuerpo
         | estruc_de_control cuerpo
         | llamar_func_o_proc OPERADOR_PUNTO_Y_COMA cuerpo
         | epsilon
         ;

/* Original, sin factoriar
asignar_valores ::= IDENTIFICADOR OPERADOR_ASIGNACION valores OPERADOR_PUNTO_Y_COMA                 // a := 12
                  | IDENTIFICADOR OPERADOR_ASIGNACION expr_aritmeticas OPERADOR_PUNTO_Y_COMA        // a := b + 3 - (4/d)..., f(...) + 12 + g(...) ...
                  | IDENTIFICADOR OPERADOR_ASIGNACION llamar_func_o_proc OPERADOR_PUNTO_Y_COMA      // f(...)
                  | IDENTIFICADOR ___operadores_aritmeticos valores OPERADOR_PUNTO_Y_COMA           // a += 12;
                  | IDENTIFICADOR ___operadores_aritmeticos expr_aritmeticas OPERADOR_PUNTO_Y_COMA  // a += 12 + b _ ...;
                  | IDENTIFICADOR __operadores_aritmeticos OPERADOR_PUNTO_Y_COMA                    // a++, b--;
                  ;
*/
asignar_valores ::= IDENTIFICADOR _asignar_valores OPERADOR_PUNTO_Y_COMA;

_asignar_valores ::= OPERADOR_ASIGNACION expr_aritmeticas
                   | ___operadores_aritmeticos expr_aritmeticas // a += 12
                   | __operadores_aritmeticos; // a++, a--

llamar_func_o_proc ::= IDENTIFICADOR OPERADOR_PARENTESIS_ABRIR parametros_llamada_func OPERADOR_PARENTESIS_CERRAR;

parametros_llamada_func ::= tokens
                        | tokens OPERADOR_COMA _parametros_llamada_func
                        | epsilon
                        ;

_parametros_llamada_func ::= tokens OPERADOR_COMA _parametros_llamada_func | tokens;

expr_read_write ::= expr_read | expr_write;

expr_read ::= READ _expr_read OPERADOR_PUNTO_Y_COMA;

_expr_read ::= _tokens | epsilon;

expr_write ::= WRITE _tokens _expr_write OPERADOR_PUNTO_Y_COMA;

_expr_write ::= _tokens _expr_write | epsilon;

// ------------------------------ Estructuras de Control ---------------------------------------------------------------

estruc_de_control ::= sentencia_if | sentencia_while | sentencia_for;

sentencia_if ::= IF expr_booleanas THEN
                 cuerpo _sentencia_if
                 END;

_sentencia_if ::= sentencia_else | epsilon;

sentencia_else ::= ELSE cuerpo;

sentencia_while ::= WHILE expr_booleanas DO
                    BEGIN
                    cuerpo
                    END;

sentencia_for ::= FOR IDENTIFICADOR OPERADOR_ASIGNACION tokens TO tokens DO
                  BEGIN
                  cuerpo
                  END;

// ------------------------------ Expresiones --------------------------------------------------------------------------

expr_aritmeticas ::= tokens
                    | llamar_func_o_proc
                    | tokens _operadores_aritmeticos expr_aritmeticas
                    | llamar_func_o_proc _operadores_aritmeticos expr_aritmeticas
                    | OPERADOR_PARENTESIS_ABRIR expr_aritmeticas OPERADOR_PARENTESIS_CERRAR _expr_aritmeticas;

_expr_aritmeticas ::= _operadores_aritmeticos expr_aritmeticas | epsilon;

expr_booleanas ::= tokens_boolean _expr_booleanas
            | _tokens operadores_booleanos _tokens _expr_booleanas
            | OPERADOR_PARENTESIS_ABRIR expr_booleanas OPERADOR_PARENTESIS_CERRAR _expr_booleanas;

_expr_booleanas ::= AND expr_booleanas | OR expr_booleanas | epsilon;

// ------------------------------ Símbolos -----------------------------------------------------------------------------

operadores_aritmeticos ::= _operadores_aritmeticos | __operadores_aritmeticos | ___operadores_aritmeticos;

_operadores_aritmeticos ::= OPERADOR_ADICION | OPERADOR_SUSTRACCION | OPERADOR_MULTIPLICACION | OPERADOR_DIVISION
                        | MOD | DIV;

__operadores_aritmeticos ::= OPERADOR_INCREMENTO | OPERADOR_DISMINUCION; // a++. a--

___operadores_aritmeticos ::= OPERADOR_ASIGNACION_ADICION | OPERADOR_ASIGNACION_SUSTRACCION
                             | OPERADOR_ASIGNACION_MULTIPLICACION | OPERADOR_ASIGNACION_DIVISION;

operadores_booleanos ::= OPERADOR_MAYOR_QUE | OPERADOR_MAYOR_IGUAL_QUE | OPERADOR_MENOR_QUE | OPERADOR_MENOR_IGUAL_QUE
                        | OPERADOR_ASIGNACION | OPERADOR_DIFERENTE_DE;

tokens ::= _tokens | tokens_boolean;

_tokens ::= IDENTIFICADOR | LITERAL_NUM_ENTERO | LITERAL_NUM_FLOTANTE | LITERAL_STRING;

tokens_boolean ::= TRUE | FALSE | NOT IDENTIFICADOR | NOT TRUE | NOT FALSE;

tipos ::= INT | SHORTINT | LONGINT | REAL | STRING | CHAR | BOOLEAN;

epsilon ::= {: RESULT = new Symbol(-1); :};